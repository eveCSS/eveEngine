

EngineStatus:
enum engineStatusT:
	eveEngIDLENOXML=1: 	No XML is loaded, engine has just be started or
						all current chains have been done 
	eveEngIDLEXML: 		XML is loaded, but chains are not yet started
	eveEngLOADINGXML:	XML is currently loading
	eveEngEXECUTING: 	at least one chain is executing 
						(execution may be paused ??) 
	eveEngPAUSED:		Pause has been activated (Button) 
	eveEngSTOPPED:		Stop has been activated (Button)
	eveEngHALTED:		Halt has been activated (Button)

 * If START, PAUSE, HALT, STOP command is received, engine status 
   changes to STARTED, PAUSED, HALTED, STOPPED.
 * Engine status is set to EXECUTING or IDLE by the appropriate
   chainStatus Message.
 * Commands are accepted only, if engineStatus is EXECUTING or IDLE.
   Exception: HALT is always accepted.
-------------------------------------------------------

enum chainStatusT {
	eveChainSmIDLE=1		chain is not yet started, ready with init
	eveChainSmINITIALIZING:	scanmodule is initializing
							(usually before idle)
	eveChainSmEXECUTING:	scanmodule/chain is executing
	eveChainSmPAUSED:		scanmodule/chain is paused
	eveChainSmTRIGGERWAIT:	scanmodule is waiting for a trigger
	eveChainSmDONE:			scanmodul is ready
	eveChainDONE:			the chain and all scanmodules are done

---------------------------------------------------------
ScanModul Status:
	eveSmNOTSTARTED: only at the very beginning
					 no start signal received yet
	eveSmINITIALIZING: is initializing, smstatus does not use this
	eveSmEXECUTING:	 executing
	eveSmTRIGGERWAIT: waiting for Trigger
	eveSmPAUSED:	 paused
	eveSmDONE:		 ready
	eveSmAPPEND: 	dieser Scan ist fertig, aber appended läuft noch
 
ScanModul Stages:
	eveStgINIT:			
	eveStgGOTOSTART
	eveStgPRESCAN
	eveStgSETTLETIME
	eveStgTRIGREAD		hier fängt die Loop an
	eveStgNEXTPOS
	eveStgPOSTSCAN
	eveStgENDPOS
	eveStgFINISH

	eveStgREADPOS macht keinen Sinn, da im scanmodul nur die benutzten Motoren
	bekannt sind, aber alle definierten Motoren gelesen werden sollen. 
	Daher ReadPos/MotorInitial in ScanManagers start-Methode verschieben
	oder vom root-Scan eine ReadPos-Methode des Scan-Managers aufrufen.
	Dort evtl nochmal unterteilen in init (vor dem Start) und read 
	(erste Aktion nach Start).
 
 * all stage Methods
 * - have signals connected to their group actions, so they are called
 *   if the group received a done event by underlaying transport
 * - if called they check if their group action is finished
 *   and set currentStageReady and emit execStage.
 * - execStage decides which stage comes next.
 
 
======================

QObject Hierarchien:

ScanThread:
	- ScanManager (kein Object-Parent!)
		- ScanModule
			- SMAxis
				- CaTransport
					- BaseTransport

==========================

Events:
	- Beim Umschalten der Pausen ist das exakte Mitzählen von 
	  sigExecStage-Signalen aufgegeben ScanModule muss nach jeder stage
	  slebst testen ob weitergegengen werden darf, nicht auf 
	  signalCounter verlassen 
	- können von GUI oder monitor kommen => Signal an ScanManager
	   ruft über den rootSM-Baum die xxxxSM-Methode mit id=0 auf
	- können von monitor direkt an SM kommen => Signal an ScanModule
	   ruft per Signal die entsprechende xxxxSM-Methode mit id!=0 auf
	
	start: 
	- beendet pause status, egal von wem gesetzt
	- starten eines nested scans im Zustand eveSmDone erfolgt durch 
	  Aufruf der startNestedSM-Methode vom Parent SM
	
	Wenn SMStatus == eveSmNOTSTARTED
		dann wird dieser Scan gestartet
	Wenn id==0
		dann wird die resumeSM-Methode aufgerufen, die den ganzen
		Baum durchsucht und alle nested Scans von Pause auf Exec setzt.
		Der Aufruf kann abgebrochen werden, sobald ein paused scan 
		gefunden wurde.
	
	resumeSM:
	- beendet pause, setzt status auf eveSmEXECUTING und schickt
	  sigExecStage. Das kann zu doppeltem sigExecStage-Signal führen,
	  wenn ein innerer Scan noch läuft.
	
	
	pause:
	- SMs können nur von executing nach pause wechseln 
	Wenn SMStatus == eveSmEXECUTING
		dann wird dieser Scan in den Status paused gesetzt
		dann wird die startSM-Methode aller nested scans aufgerufen.
		(da sie auch executing sein können), der Aufruf kann abgebrochen
		werden, sobald ein nested scan nicht executing ist.
	id == 0 && SMStatus != executing
		dann wird auch die pauseSM-Methode aller appended scans aufgerufen.

	halt:
	- gibt es nur als GUI-Befehl
	Wenn SMStatus != eveSmDONE
		Wenn SMStatus == eveSmPAUSED
			dann status auf eveSmEXECUTING setzen
		Wenn SMStatus == eveSmEXECUTING oder SMStatus == eveSmPAUSED
			dann prüfen ob stage == StgGotoStart oder StgNextPos
				=> MotorStop schicken
			dann status auf eveStgPOSTSCAN und currentStageReady=true setzen.

	stop:
		wie halt ohne Motor anhalten
	
	break:
	- falls von GUI ausgelöst, dann nur den innersten Scan anhalten,
	  d.h. erst die nested-break-Methode aufrufen, dann inneren Scan testen,
	  falls der ein break ausgelöst hat, dann kein break auslösen

	Wenn id == 0 && (SMStatus == eveSmEXECUTING oder SMStatus == eveSmPAUSED)
		dann prüfen ob nested-scan einen break ausgeführt hat, 
		wenn nicht dann status auf eveStgNextPos und currentStageReady=true setzen.
	Wenn id == 0 && !(SMStatus == eveSmEXECUTING oder SMStatus == eveSmPAUSED)
		dann appended scan breakSM aufrufen
	Wenn id != 0
		wenn (SMStatus == eveSmEXECUTING oder SMStatus == eveSmPAUSED)
		dann status auf eveStgNextPos und currentStageReady=true setzen.
	redo:
		redo-Flag im SM setzen


	
	


 