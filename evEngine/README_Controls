

EngineStatus:
enum engineStatusT:
	eveEngIDLENOXML=1: 	No XML is loaded, engine has just be started or
						all current chains have been done 
	eveEngIDLEXML: 		XML is loaded, but chains are not yet started
	eveEngLOADINGXML:	XML is currently loading
	eveEngEXECUTING: 	at least one chain is executing 
						(execution may be paused ??) 
	eveEngPAUSED:		Pause has been activated (Button) 
	eveEngSTOPPED:		Stop has been activated (Button)
	eveEngHALTED:		Halt has been activated (Button)

 * If START, PAUSE, HALT, STOP command is received, engine status 
   changes to STARTED, PAUSED, HALTED, STOPPED.
 * Engine status is set to EXECUTING or IDLE by the appropriate
   chainStatus Message.
 * Commands are accepted only, if engineStatus is EXECUTING or IDLE.
   Exception: HALT is always accepted.
-------------------------------------------------------

enum chainStatusT {
	eveChainSmIDLE=1		chain is not yet started, ready with init
	eveChainSmINITIALIZING:	scanmodule is initializing
							(usually before idle)
	eveChainSmEXECUTING:	scanmodule/chain is executing
	eveChainSmPAUSED:		scanmodule/chain is paused
	eveChainSmTRIGGERWAIT:	scanmodule is waiting for a trigger
	eveChainSmDONE:			scanmodul is ready
	eveChainDONE:			the chain and all scanmodules are done

---------------------------------------------------------
ScanModul Status:
	eveSmNOTSTARTED: only at the very beginning
					 no start signal received yet
	eveSmEXECUTING:	 executing
	eveSmPAUSED:	 paused
	eveSmBROKEN:	 break signal received
	eveSmHALTED:	 Halt signal received
	eveSmDONE:		 ready
 
ScanModul Stages:
	eveStgINIT:			
	eveStgGOTOSTART
	eveStgPRESCAN
	eveStgSETTLETIME
	eveStgTRIGREAD		hier f√§ngt die Loop an
	eveStgNEXTPOS
	eveStgPOSTSCAN
	eveStgENDPOS
	eveStgFINISH

	eveStgREADPOS macht keinen Sinn, da im scanmodul nur die benutzten Motoren
	bekannt sind, aber alle definierten Motoren gelesen werden sollen. 
	Daher ReadPos/MotorInitial in ScanManagers start-Methode verschieben.
	Dort evtl nochmal unterteilen in init (vor dem Start) und read 
	(erste Aktion nach Start).
 
 * all stage Methods
 * - have signals connected to their group actions, so they are called
 *   if the group received a done event by underlaying transport
 * - if called they check if their group action is finished
 *   and set currentStageReady and emit execStage.
 * - execStage decides which stage comes next.
 